{% extends "base.html" %} {% block title %}LifeLine â€“ Live Map{% endblock %} {%
block content %}

<section
  class="w-full min-h-screen home-hero text-slate-100 px-6 md:px-12 py-8 md:py-10 space-y-4 page-transition"
>
  <!-- Header -->
  <div
    class="flex flex-col md:flex-row md:items-center md:justify-between gap-3 stagger-item"
  >
    <div>
      <h2 class="text-xl md:text-2xl font-semibold mb-1">
        Live neighborhood map
      </h2>
      <p class="text-sm text-slate-400 max-w-2xl">
        See help requests and offers around you in real time. Click a card to
        focus on a request, or use the filters to view only medicine runs, ride
        offers, or general help.
      </p>
    </div>

    <div class="flex flex-col gap-3">
      <!-- Radar button -->
      <button
        id="radar-toggle-btn"
        class="btn-sheen px-4 py-2 rounded-full bg-gradient-to-r from-purple-500 to-pink-500 text-white text-sm font-semibold hover:opacity-90 transition flex items-center justify-center gap-2 shadow-lg"
        type="button"
        title="Activate Human Availability Radar"
      >
        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
          <path
            fill-rule="evenodd"
            d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z"
            clip-rule="evenodd"
          />
        </svg>
        Availability Radar
      </button>

      <div class="text-[10px] text-slate-400 space-y-1">
        <p class="font-semibold text-slate-200">Pin colors</p>
        <p>
          <span
            class="inline-block h-2 w-2 rounded-full bg-[#22c55e] mr-1"
          ></span>
          Need â€“ normal/low
        </p>
        <p>
          <span
            class="inline-block h-2 w-2 rounded-full bg-[#f97316] mr-1"
          ></span>
          Need â€“ high
        </p>
        <p>
          <span
            class="inline-block h-2 w-2 rounded-full bg-[#ef4444] mr-1"
          ></span>
          Need â€“ emergency
        </p>
        <p>
          <span
            class="inline-block h-2 w-2 rounded-full bg-[#3b82f6] mr-1"
          ></span>
          Helper offers (radius shown if set)
        </p>
      </div>
    </div>
  </div>

  <!-- Main content: Map + Sidebar -->
  <div class="grid lg:grid-cols-3 gap-4 lg:gap-6">
    <!-- MAP COLUMN -->
    <div class="lg:col-span-2 relative stagger-item">
      <!-- Top overlay controls -->
      <div class="absolute z-20 top-3 left-3 flex flex-col gap-2">
        <div
          class="rounded-2xl bg-slate-900/80 border border-slate-700/70 px-3 py-2 text-[11px] text-slate-200 shadow-lg card-hover"
        >
          <div class="flex items-center gap-2">
            <span
              class="h-2 w-2 rounded-full bg-emerald-400 animate-pulse"
            ></span>
            <span class="font-semibold"
              >Live radius: <span id="radius-label">3 km</span></span
            >
          </div>
          <p id="map-status" class="text-[10px] text-slate-400 mt-1">
            Detecting your locationâ€¦
          </p>
        </div>
      </div>

      <!-- Bottom-left recenter button -->
      <button
        id="recenter-btn"
        class="btn-sheen absolute z-20 bottom-3 left-3 px-3 py-1.5 rounded-full bg-slate-900/80 border border-slate-700 text-[11px] text-slate-200 hover:border-emerald-400 hover:text-emerald-300 transition shadow-lg"
        type="button"
      >
        Recenter on me
      </button>

      <!-- MAP BOX -->
      <div
        id="map"
        class="w-full rounded-3xl glass-card-enhanced card-hover"
        style="height: 500px"
      ></div>
    </div>

    <!-- SIDEBAR: LIST OF REQUESTS -->
    <div
      class="flex flex-col rounded-3xl glass-card-enhanced backdrop-blur p-4 shadow-xl max-h-[500px] card-hover stagger-item"
    >
      <!-- Filters -->
      <div class="flex flex-wrap gap-2 mb-3 text-[11px]">
        <button
          class="filter-btn btn-sheen px-3 py-1.5 rounded-full border border-emerald-400/60 bg-emerald-500/10 text-emerald-200 font-semibold"
          data-filter="all"
          type="button"
        >
          All
        </button>
        <button
          class="filter-btn btn-sheen px-3 py-1.5 rounded-full border border-slate-700 text-slate-300 hover:border-emerald-400 hover:text-emerald-300 transition"
          data-filter="help"
          type="button"
        >
          Help Needed
        </button>
        <button
          class="filter-btn btn-sheen px-3 py-1.5 rounded-full border border-slate-700 text-slate-300 hover:border-sky-400 hover:text-sky-300 transition"
          data-filter="medicine"
          type="button"
        >
          Medicine Run
        </button>
        <button
          class="filter-btn btn-sheen px-3 py-1.5 rounded-full border border-slate-700 text-slate-300 hover:border-amber-400 hover:text-amber-300 transition"
          data-filter="ride"
          type="button"
        >
          Ride Offer
        </button>
      </div>

      <!-- Summary -->
      <div
        class="flex items-center justify-between mb-2 text-[11px] text-slate-400"
      >
        <span id="requests-summary">No requests loaded yet.</span>
        <span class="text-slate-500">Auto-refresh every 10s</span>
      </div>

      <!-- Scrollable list -->
      <div
        id="requests-list"
        class="mt-1 space-y-2 overflow-y-auto pr-1 custom-scrollbar text-xs"
      >
        <!-- JS will inject cards here -->
      </div>
    </div>
  </div>
</section>

<div
  id="lifeline-map-config"
  class="hidden"
  data-is-trusted-helper="{{ '1' if session.get('is_trusted_helper') else '0' }}"
  data-current-user-id="{{ session.get('user_id') or '' }}"
  data-emergency-number="{{ user.emergency_number or '' }}"
></div>

<script>
  let map;
  let userMarker = null;
  let requestMarkers = []; // { marker, infoWindow, data }
  let helperCircles = []; // radius circles for offers
  let userPosition = null;
  let lastRequests = [];
  let activeFilter = "all";
  let currentRadiusKm = 3;

  const __lifelineCfg = document.getElementById("lifeline-map-config");
  const IS_TRUSTED_HELPER =
    (__lifelineCfg?.dataset?.isTrustedHelper || "0") === "1";
  const CURRENT_USER_ID = __lifelineCfg?.dataset?.currentUserId
    ? parseInt(__lifelineCfg.dataset.currentUserId, 10)
    : null;
  const EMERGENCY_NUMBER = __lifelineCfg?.dataset?.emergencyNumber || "";

  let sosPulseItems = []; // [{ polygons: [{ polygon, offset, baseStrokeOpacity, baseFillOpacity }], center: {lat,lng}, requestId }]
  let sosPulseAnimId = null;
  let autoFocusDone = false;
  let sosFallbackStarted = false;
  let sosResponderMarkers = [];
  let sosResponderTrackingStarted = false;

  // Availability Radar state
  let radarEnabled = false;
  let heatmapLayer = null;
  let radarMarkers = [];
  let radarRefreshInterval = null;
  let radarCircles = [];
  let radarDidFit = false;

  const INITIAL_FOCUS_ID = getQueryParamInt("focus_request_id");
  const IS_SOS_CALLER = {{ 1 if is_sos_caller else 0 }};
  const GUEST_SOS_REQUEST_ID = {{ guest_sos_request_id or 'null' }};
  let mapDidInitialFit = false;
  let userInteractedWithMap = false;
  let programmaticZoom = false;

  // Pin colors based on role (need vs offer) + urgency
  const ICON_URLS = {
    need: {
      emergency: "http://maps.google.com/mapfiles/ms/icons/red-dot.png",
      high: "http://maps.google.com/mapfiles/ms/icons/orange-dot.png",
      normal: "http://maps.google.com/mapfiles/ms/icons/green-dot.png",
      low: "http://maps.google.com/mapfiles/ms/icons/ltblue-dot.png",
    },
    offer: {
      emergency: "http://maps.google.com/mapfiles/ms/icons/purple-dot.png",
      high: "http://maps.google.com/mapfiles/ms/icons/purple-dot.png",
      normal: "http://maps.google.com/mapfiles/ms/icons/blue-dot.png",
      low: "http://maps.google.com/mapfiles/ms/icons/blue-dot.png",
    },
  };

  function getQueryParamInt(name) {
    const params = new URLSearchParams(window.location.search);
    const v = params.get(name);
    if (!v) return null;
    const n = parseInt(v, 10);
    return Number.isFinite(n) ? n : null;
  }

  function getQueryParamBool(name) {
    const params = new URLSearchParams(window.location.search);
    const v = params.get(name);
    return v === "1" || v === "true";
  }

  function normalizePhoneForTel(number) {
    if (!number) return "";
    const trimmed = String(number).trim();
    const keepPlus = trimmed.startsWith("+");
    const digits = trimmed.replace(/[^0-9]/g, "");
    return keepPlus ? `+${digits}` : digits;
  }

  function openSosCallModal(number) {
    const modal = document.getElementById("sos-call-modal");
    const link = document.getElementById("sos-call-link");
    const text = document.getElementById("sos-call-text");
    const closeBtn = document.getElementById("sos-call-close");
    if (!modal || !link || !text || !closeBtn) return;

    if (number) {
      const tel = normalizePhoneForTel(number);
      link.href = tel ? `tel:${tel}` : `tel:${number}`;
      link.textContent = "Call now";
      text.textContent = `Calling ${number}â€¦ (simulated)`;
      link.classList.remove("pointer-events-none", "opacity-60");
    } else {
      link.href = "{{ url_for('profile') }}";
      text.textContent =
        "No emergency number saved. Add one in your profile to enable auto-call.";
      link.textContent = "Open profile";
    }

    modal.classList.remove("hidden");

    const close = () => modal.classList.add("hidden");
    closeBtn.onclick = close;
    modal.addEventListener(
      "click",
      (e) => {
        if (e.target === modal) close();
      },
      { once: true }
    );
  }

  function buildRequestInfoHtml(r) {
    const isSos = (r.category || "").toLowerCase() === "sos";
    const viewerResponded = !!r.viewer_sos_responded;
    const canRespond =
      isSos &&
      IS_TRUSTED_HELPER &&
      CURRENT_USER_ID &&
      r.user_id !== CURRENT_USER_ID &&
      !viewerResponded;

    const respondedBadge =
      isSos && IS_TRUSTED_HELPER && viewerResponded
        ? `<div style="margin-top: 8px; width: 100%; background: #0f172a; color: #34d399; border: 1px solid rgba(52, 211, 153, 0.35); padding: 8px 10px; border-radius: 10px; font-weight: 700; font-size: 12px; text-align: center;">âœ“ Responded</div>`
        : "";

    // Allow resolve if:
    // - (1) This is an SOS
    // - (2) (a) User is SOS caller (session) and focus matches, OR
    //      (b) Guest session matches guest_sos_request_id
    const canResolveAsCaller =
      isSos && (
        (IS_SOS_CALLER && INITIAL_FOCUS_ID && r.id === INITIAL_FOCUS_ID) ||
        (GUEST_SOS_REQUEST_ID && r.id === GUEST_SOS_REQUEST_ID)
      );

    return `
      <div style="max-width: 240px;">
        <h3 style="font-size: 14px; margin-bottom: 4px;">${r.title}</h3>
        <p style="font-size: 12px; color: #64748b; margin-bottom: 4px;">
          ${r.description || ""}
        </p>
        <p style="font-size: 11px; color: #22c55e; margin-bottom: 2px;">
          ~ ${r.distance_km} km away
        </p>
        ${
          isSos
            ? `<p style="font-size: 11px; color: #ef4444; margin-bottom: 4px; font-weight: 700;">SOS SIGNAL â€¢ Trusted helpers alerted</p>`
            : ""
        }
        ${
          r.urgency
            ? `<p style="font-size: 11px; color: #f97316;">Urgency: ${r.urgency}</p>`
            : ""
        }
        ${
          r.is_offer
            ? `<p style="font-size: 11px; color: #38bdf8;">Helper offer${
                r.radius_pref ? " â€¢ radius " + r.radius_pref + " km" : ""
              }</p>`
            : ""
        }
        ${
          canRespond
            ? `<button onclick="respondToSOS(${r.id})" style="margin-top: 8px; width: 100%; background: #ef4444; color: white; border: 0; padding: 8px 10px; border-radius: 10px; font-weight: 700; font-size: 12px; cursor: pointer;">Respond to SOS</button>`
            : ""
        }
        ${respondedBadge}
        ${
          canResolveAsCaller
            ? `<button onclick="resolveSOS(${r.id})" style="margin-top: 8px; width: 100%; background: #22c55e; color: #0b172a; border: 0; padding: 8px 10px; border-radius: 10px; font-weight: 800; font-size: 12px; cursor: pointer;">Mark Resolved</button>`
            : ""
        }
      </div>
    `;
  }

  async function resolveSOS(requestId) {
    if (!confirm("Mark this SOS as resolved?")) return;
    try {
      const resp = await fetch(`/api/sos/${requestId}/resolve`, {
        method: "POST",
        credentials: "include",
      });
      const data = await resp.json().catch(() => ({}));
      if (!resp.ok) {
        alert(data.error || "Failed to resolve SOS");
        return;
      }
      alert("SOS marked resolved.");
      window.location.href = "/";
    } catch (e) {
      alert("Failed to resolve SOS");
    }
  }
  window.resolveSOS = resolveSOS;

  const sosRespondInFlight = new Set();

  async function respondToSOS(requestId) {
    if (sosRespondInFlight.has(requestId)) return;
    sosRespondInFlight.add(requestId);
    try {
      const send = async (payload) => {
        const resp = await fetch(`/api/sos/${requestId}/respond`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload || {}),
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) {
          alert(data.error || "Failed to respond to SOS");
          return;
        }
        // Update local state immediately so the UI shows "Responded" without waiting for refresh.
        try {
          for (const r of lastRequests) {
            if (r && r.id === requestId) {
              r.viewer_sos_responded = true;
            }
          }
          for (const item of requestMarkers) {
            if (item && item.data && item.data.id === requestId) {
              item.data.viewer_sos_responded = true;
            }
          }
          renderRequests();
        } catch (e) {}
        focusOnRequest(requestId);
      };

      // Respond immediately so UX isn't blocked on geolocation.
      await send({});

      // Best-effort: attach a location shortly after responding.
      if (!navigator.geolocation) return;
      navigator.geolocation.getCurrentPosition(
        async (pos) => {
          try {
            await send({ lat: pos.coords.latitude, lng: pos.coords.longitude });
          } catch (e) {}
        },
        async () => {
          // Ignore geolocation errors.
        },
        { enableHighAccuracy: false, timeout: 1500, maximumAge: 60000 }
      );
    } catch (e) {
      console.error(e);
      alert("Failed to respond to SOS");
    } finally {
      // Allow re-try after a short moment.
      setTimeout(() => sosRespondInFlight.delete(requestId), 1500);
    }
  }
  window.respondToSOS = respondToSOS;

  function clearSosResponderMarkers() {
    for (const m of sosResponderMarkers) {
      try {
        m.setMap(null);
      } catch (e) {}
    }
    sosResponderMarkers = [];
  }

  function updateSosResponderMarkers(responderLocations) {
    clearSosResponderMarkers();
    if (!Array.isArray(responderLocations) || responderLocations.length === 0)
      return;

    for (const r of responderLocations) {
      if (r.lat == null || r.lng == null) continue;
      const pos = { lat: r.lat, lng: r.lng };
      const marker = new google.maps.Marker({
        position: pos,
        map: map,
        title: r.name ? `${r.name} (Responder)` : "SOS Responder",
        icon: "http://maps.google.com/mapfiles/ms/icons/blue-dot.png",
      });
      sosResponderMarkers.push(marker);
    }
  }

  function startSosResponderTracking(sosRequestId) {
    if (sosResponderTrackingStarted) return;
    sosResponderTrackingStarted = true;

    const loop = async () => {
      try {
        const resp = await fetch(`/api/sos/${sosRequestId}/status`, {
          credentials: "include",
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) return;

        if (
          Array.isArray(data.responder_locations) &&
          data.responder_locations.length
        ) {
          updateSosResponderMarkers(data.responder_locations);
        }
      } catch (e) {
        // ignore
      }
      setTimeout(loop, 5000);
    };

    setTimeout(loop, 1500);
  }

  function destinationPoint(lat, lng, bearingDeg, distanceMeters) {
    const R = 6378137;
    const brng = (bearingDeg * Math.PI) / 180;
    const lat1 = (lat * Math.PI) / 180;
    const lon1 = (lng * Math.PI) / 180;
    const dr = distanceMeters / R;

    const lat2 = Math.asin(
      Math.sin(lat1) * Math.cos(dr) +
        Math.cos(lat1) * Math.sin(dr) * Math.cos(brng)
    );
    const lon2 =
      lon1 +
      Math.atan2(
        Math.sin(brng) * Math.sin(dr) * Math.cos(lat1),
        Math.cos(dr) - Math.sin(lat1) * Math.sin(lat2)
      );

    return { lat: (lat2 * 180) / Math.PI, lng: (lon2 * 180) / Math.PI };
  }

  function hexagonPath(center, radiusMeters) {
    // 6 points around the center; rotate 30deg so it looks like a "hex signal"
    const bearings = [30, 90, 150, 210, 270, 330];
    return bearings.map((b) =>
      destinationPoint(center.lat, center.lng, b, radiusMeters)
    );
  }

  function clearSosPulses() {
    for (const item of sosPulseItems) {
      try {
        for (const p of item.polygons) {
          p.polygon.setMap(null);
        }
      } catch (e) {}
    }
    sosPulseItems = [];
  }

  function ensureSosPulseAnimation() {
    if (sosPulseAnimId && sosPulseItems.length === 0) {
      cancelAnimationFrame(sosPulseAnimId);
      sosPulseAnimId = null;
      return;
    }
    if (sosPulseAnimId || sosPulseItems.length === 0) return;

    const minR = 60;
    const maxR = 1000;
    const periodMs = 2600;

    const animate = (t) => {
      if (sosPulseItems.length === 0) {
        sosPulseAnimId = null;
        return;
      }

      for (const item of sosPulseItems) {
        for (const p of item.polygons) {
          // Option B: Expand only (no shrink), and fade out as it expands.
          const phase01 = ((t % periodMs) / periodMs + (p.offset || 0)) % 1;
          const radius = minR + (maxR - minR) * phase01;

          // Fade-out curve: strong at start, near 0 at the edge
          const fade = Math.max(0, 1 - phase01);
          const easedFade = fade * fade;

          const path = hexagonPath(item.center, radius);
          p.polygon.setPath(path);
          p.polygon.setOptions({
            strokeOpacity: (p.baseStrokeOpacity || 0.25) * easedFade,
            fillOpacity: (p.baseFillOpacity || 0.08) * easedFade,
          });
        }
      }

      sosPulseAnimId = requestAnimationFrame(animate);
    };

    sosPulseAnimId = requestAnimationFrame(animate);
  }

  function syncSosPulsesFromRequests(requests) {
    clearSosPulses();
    for (const r of requests) {
      const isSos = (r.category || "").toLowerCase() === "sos";
      if (!isSos || r.lat == null || r.lng == null) continue;

      const center = { lat: r.lat, lng: r.lng };
      // Multiple rings to feel like a continuous broadcast signal
      const ringOffsets = [0, 0.2, 0.4, 0.6, 0.8];
      const polygons = ringOffsets.map((off, idx) => {
        const baseStrokeOpacity = idx === 0 ? 0.85 : 0.55;
        const baseFillOpacity = idx === 0 ? 0.22 : 0.12;
        const poly = new google.maps.Polygon({
          paths: hexagonPath(center, 60),
          strokeColor: "#ef4444",
          strokeOpacity: baseStrokeOpacity,
          strokeWeight: idx === 0 ? 3 : 2,
          fillColor: "#ef4444",
          fillOpacity: baseFillOpacity,
          clickable: false,
          zIndex: 999,
        });
        poly.setMap(map);
        return {
          polygon: poly,
          offset: off,
          baseStrokeOpacity,
          baseFillOpacity,
        };
      });

      sosPulseItems.push({ polygons, center, requestId: r.id });
    }

    ensureSosPulseAnimation();
  }

  async function startSosCallerFallbackTimer(sosRequestId) {
    if (sosFallbackStarted) return;
    sosFallbackStarted = true;

    const loop = async () => {
      try {
        const resp = await fetch(`/api/sos/${sosRequestId}/status`, {
          credentials: "include",
        });
        const data = await resp.json().catch(() => ({}));
        if (resp.ok && data.responded) {
          return; // helper responded; do nothing
        }

        // Server-driven fallback (based on request created_at)
        if (resp.ok && data.should_call) {
          openSosCallModal(EMERGENCY_NUMBER);
          return;
        }
      } catch (e) {
        // ignore transient failures
      }

      setTimeout(loop, 5000);
    };

    setTimeout(loop, 5000);
  }

  // Start the no-response fallback timer ASAP for SOS callers.
  // This makes the auto-call modal appear even if map refresh/focus fails.
  document.addEventListener("DOMContentLoaded", () => {
    try {
      if (INITIAL_FOCUS_ID && getQueryParamBool("sos_caller")) {
        startSosCallerFallbackTimer(INITIAL_FOCUS_ID);
      }
    } catch (e) {
      // ignore
    }
  });

  // ================== AVAILABILITY RADAR FUNCTIONS ==================

  function clearRadarMarkers() {
    for (const marker of radarMarkers) {
      try {
        marker.setMap(null);
      } catch (e) {}
    }
    radarMarkers = [];
  }

  function clearRadarHeatmap() {
    if (heatmapLayer) {
      try {
        heatmapLayer.setMap(null);
      } catch (e) {}
      heatmapLayer = null;
    }
  }

  function clearRadarCircles() {
    if (radarCircles && radarCircles.length) {
      for (const c of radarCircles) {
        try { c.setMap(null); } catch (e) {}
      }
    }
    radarCircles = [];
  }

  function jitterLatLng(lat, lng, meters, seedIndex) {
    // Deterministic tiny jitter to avoid perfect overlap
    try {
      const R = 6378137; // Earth radius in meters
      const angle = (seedIndex * 137.508) % 360; // golden angle for distribution
      const dist = Math.min(Math.max(meters * 0.5, 1), Math.abs(meters));
      const brng = (angle * Math.PI) / 180;
      const lat1 = (lat * Math.PI) / 180;
      const lon1 = (lng * Math.PI) / 180;
      const dr = dist / R;
      const lat2 = Math.asin(
        Math.sin(lat1) * Math.cos(dr) +
          Math.cos(lat1) * Math.sin(dr) * Math.cos(brng)
      );
      const lon2 =
        lon1 +
        Math.atan2(
          Math.sin(brng) * Math.sin(dr) * Math.cos(lat1),
          Math.cos(dr) - Math.sin(lat1) * Math.sin(lat2)
        );
      return { lat: (lat2 * 180) / Math.PI, lng: (lon2 * 180) / Math.PI };
    } catch (e) {
      return { lat, lng };
    }
  }

  function styleInfoWindow(infoWindow) {
    if (!infoWindow) return;
    infoWindow.addListener("domready", () => {
      try {
        const iwOuter = document.querySelector(".gm-style-iw");
        const iwInner = document.querySelector(".gm-style-iw-d");
        const closeBtn = document.querySelector(".gm-ui-hover-effect");
        if (iwOuter) {
          iwOuter.parentElement.style.borderRadius = "12px";
          iwOuter.parentElement.style.boxShadow = "0 10px 30px rgba(0,0,0,0.35)";
          iwOuter.style.background = "transparent";
          iwOuter.style.boxShadow = "none";
        }
        if (iwInner) {
          iwInner.style.padding = "0";
          iwInner.style.overflow = "visible";
        }
        if (closeBtn) {
          closeBtn.style.opacity = "0.9";
          closeBtn.style.right = "8px";
          closeBtn.style.top = "8px";
          closeBtn.style.borderRadius = "50%";
          closeBtn.style.boxShadow = "0 2px 8px rgba(0,0,0,0.25)";
        }
        const tails = document.querySelectorAll("div[style*='transform: rotate(45deg)']");
        tails.forEach((t) => {
          t.style.background = "#0b1220";
          t.style.boxShadow = "0 6px 20px rgba(0,0,0,0.35)";
        });
      } catch (e) {}
    });
  }

  async function recordActivityPing() {
    /**Send activity ping to backend for radar tracking*/
    if (!userPosition) {
      console.error("User position not available for activity ping");
      return;
    }

    try {
      console.log("Recording activity ping from:", userPosition);
      const response = await fetch("/api/activity/ping", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify({
          lat: userPosition.lat,
          lng: userPosition.lng,
          activity_type: "ping",
          device_motion: 30 + Math.random() * 40 // Simulate some device motion (0-100)
        })
      });
      console.log("Activity ping response:", response.status);
    } catch (e) {
      console.error("Failed to record activity ping:", e);
    }
  }

  async function recordActivityPingWithPosition(position) {
    /**Send activity ping with explicit position*/
    if (!position) return;

    try {
      console.log("Recording activity ping from:", position);
      const posLat = typeof position.lat === 'function' ? position.lat() : position.lat;
      const posLng = typeof position.lng === 'function' ? position.lng() : position.lng;
        console.log("Activity ping with lat:", posLat, "lng:", posLng);

      const response = await fetch("/api/activity/ping", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify({
          lat: posLat,
          lng: posLng,
          activity_type: "ping",
          device_motion: 30 + Math.random() * 40
        })
      });
      console.log("Activity ping response:", response.status);
    } catch (e) {
      console.error("Failed to record activity ping:", e);
    }
  }

  async function updateRadarHeatmap() {
    /**Fetch and display the availability heatmap*/
    if (!userPosition) {
      console.error("User position not available for radar");
      return;
    }

    try {
      console.log("Updating radar heatmap from position:", userPosition);
      const resp = await fetch("/api/radar/heatmap", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify({
          user_lat: userPosition.lat,
          user_lng: userPosition.lng,
          radius_km: currentRadiusKm,
          window_min: 120
        })
      });

      if (!resp.ok) {
        console.error("Heatmap API error:", resp.status);
        return;
      }

      const data = await resp.json();
      console.log("Heatmap data received:", data);
      if (!data.ok || !Array.isArray(data.heatmap_points)) {
        console.error("Invalid heatmap data:", data);
        return;
      }
      const statusEl = document.getElementById("map-status");
      if (statusEl && typeof data.total_active_nearby === 'number') {
        statusEl.innerText = `Radar: ${data.total_active_nearby} active nearby`;
      }

      // Clear old layers
      clearRadarHeatmap();
      clearRadarMarkers();
      clearRadarCircles();

      // Create heatmap data for Google Maps
      const heatmapData = data.heatmap_points.map(point => ({
        location: new google.maps.LatLng(point.lat, point.lng),
        weight: point.weight * 100 // Scale weight for heatmap
      }));

      // Force fallback circles so everyone is visible without billing
      let heatmapRendered = false;

      // Fallback: draw soft circles if heatmap not available
      if (!heatmapRendered) {
        data.heatmap_points.forEach((point, idx) => {
          const baseColor = point.is_helper ? "#3b82f6" : "#8b5cf6"; // blue or purple
          const opacity = Math.min(0.65, 0.28 + point.weight * 0.35);
          const radiusMeters = 600 + point.weight * 1400; // ~0.6km - 2km
          const center = jitterLatLng(point.lat, point.lng, 40, idx);
          const circle = new google.maps.Circle({
            strokeOpacity: 0,
            fillColor: baseColor,
            fillOpacity: opacity,
            center,
            radius: radiusMeters,
            map: map,
            zIndex: 1
          });
          radarCircles.push(circle);
        });
      }

      // Add markers for top active users
      data.heatmap_points.slice(0, 15).forEach((point, idx) => {
        const color = point.is_helper ? "#3b82f6" : "#a78bfa";
        const jittered = jitterLatLng(point.lat, point.lng, 25, idx + 7);
        const marker = new google.maps.Marker({
          position: jittered,
          map: map,
          title: `${point.name} (Activity: ${point.activity_count})`,
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 7 + point.weight * 8,
            fillColor: color,
            fillOpacity: 0.9,
            strokeColor: "#0f172a",
            strokeWeight: 1,
          },
          zIndex: 2,
          label: {
            text: point.is_helper ? "H" : "M",
            color: "#ffffff",
            fontSize: "10px",
            fontWeight: "700",
          },
        });

        const infoContent = `
          <div style="background: #0b1220; color: #e5e7eb; padding: 8px 10px; border-radius: 10px; min-width: 180px; font-size: 13px; line-height: 1.35;">
            <p style="margin: 0 0 4px 0; font-weight: 800; color: #f8fafc;">${point.name}</p>
            <p style="margin: 0 0 4px 0; font-weight: 600; color: ${point.is_helper ? "#60a5fa" : "#c084fc"};">
              ${point.is_helper ? "ðŸ”µ Verified Helper" : "ðŸ‘¤ Community Member"}
            </p>
            <p style="margin: 0; color: #34d399; font-weight: 700; font-size: 12px;">
              Activity: ${point.activity_count} events
            </p>
          </div>
        `;

        marker.addListener("click", () => {
          const infoWindow = new google.maps.InfoWindow({
            content: infoContent,
            ariaLabel: point.name
          });
          styleInfoWindow(infoWindow);
          infoWindow.open(map, marker);
        });

        radarMarkers.push(marker);
      });

      // Fit bounds on first render after enabling radar
      try {
        if (!radarDidFit && Array.isArray(data.heatmap_points) && data.heatmap_points.length) {
          const b = new google.maps.LatLngBounds();
          data.heatmap_points.slice(0, 15).forEach((p, i) => {
            const jp = jitterLatLng(p.lat, p.lng, 25, i + 13);
            b.extend(new google.maps.LatLng(jp.lat, jp.lng));
          });
          if (userPosition) b.extend(new google.maps.LatLng(userPosition.lat, userPosition.lng));
          map.fitBounds(b, 80);
          radarDidFit = true;
        }
      } catch (e) {}
    } catch (e) {
      console.error("Failed to update radar heatmap:", e);
    }
  }

  async function updateRadarHeatmapWithPosition(position) {
    /**Fetch and display heatmap with explicit position*/
    if (!position) return;

    try {
      console.log("Updating radar heatmap from position:", position);
      // Handle both {lat, lng} objects and Google Maps LatLng objects
      const posLat = typeof position.lat === 'function' ? position.lat() : position.lat;
      const posLng = typeof position.lng === 'function' ? position.lng() : position.lng;

      console.log("Heatmap request with lat:", posLat, "lng:", posLng);

      const resp = await fetch("/api/radar/heatmap", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify({
          user_lat: posLat,
          user_lng: posLng,
          radius_km: currentRadiusKm,
          window_min: 120
        })
      });

      if (!resp.ok) {
        console.error("Heatmap API error:", resp.status);
        return;
      }

      const data = await resp.json();
      console.log("Heatmap data received:", data);
      if (!data.ok || !Array.isArray(data.heatmap_points)) {
        console.error("Invalid heatmap data:", data);
        return;
      }
      const statusEl = document.getElementById("map-status");
      if (statusEl && typeof data.total_active_nearby === 'number') {
        statusEl.innerText = `Radar: ${data.total_active_nearby} active nearby`;
      }

      // Clear old layers
      clearRadarHeatmap();
      clearRadarMarkers();
      clearRadarCircles();

      // Create heatmap data for Google Maps
      const heatmapData = data.heatmap_points.map(point => ({
        location: new google.maps.LatLng(point.lat, point.lng),
        weight: point.weight * 100
      }));

      // Force fallback circles so everyone is visible without billing
      let heatmapRendered = false;

      // Fallback: draw soft circles if heatmap not available
      if (!heatmapRendered) {
        data.heatmap_points.forEach((point, idx) => {
          const baseColor = point.is_helper ? "#3b82f6" : "#8b5cf6";
          const opacity = Math.min(0.65, 0.28 + point.weight * 0.35);
          const radiusMeters = 600 + point.weight * 1400;
          const center = jitterLatLng(point.lat, point.lng, 40, idx + 3);
          const circle = new google.maps.Circle({
            strokeOpacity: 0,
            fillColor: baseColor,
            fillOpacity: opacity,
            center,
            radius: radiusMeters,
            map: map,
            zIndex: 1
          });
          radarCircles.push(circle);
        });
      }

      // Add markers for top active users
      data.heatmap_points.slice(0, 15).forEach((point, idx) => {
        const color = point.is_helper ? "#3b82f6" : "#a78bfa";
        const jittered = jitterLatLng(point.lat, point.lng, 25, idx + 17);
        const marker = new google.maps.Marker({
          position: jittered,
          map: map,
          title: `${point.name} (Activity: ${point.activity_count})`,
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 7 + point.weight * 8,
            fillColor: color,
            fillOpacity: 0.9,
            strokeColor: "#0f172a",
            strokeWeight: 1
          },
          zIndex: 2,
          label: {
            text: point.is_helper ? "H" : "M",
            color: "#ffffff",
            fontSize: "10px",
            fontWeight: "700",
          },
        });

        const infoContent = `
          <div style="background: #0b1220; color: #e5e7eb; padding: 8px 10px; border-radius: 10px; min-width: 180px; font-size: 13px; line-height: 1.35;">
            <p style="margin: 0 0 4px 0; font-weight: 800; color: #f8fafc;">${point.name}</p>
            <p style="margin: 0 0 4px 0; font-weight: 600; color: ${point.is_helper ? "#60a5fa" : "#c084fc"};">
              ${point.is_helper ? "ðŸ”µ Verified Helper" : "ðŸ‘¤ Community Member"}
            </p>
            <p style="margin: 0; color: #34d399; font-weight: 700; font-size: 12px;">
              Activity: ${point.activity_count} events
            </p>
          </div>
        `;

        marker.addListener("click", () => {
          const infoWindow = new google.maps.InfoWindow({
            content: infoContent,
            ariaLabel: point.name
          });
          styleInfoWindow(infoWindow);
          infoWindow.open(map, marker);
        });

        radarMarkers.push(marker);
      });

      // Fit bounds on first render after enabling radar
      try {
        if (!radarDidFit && Array.isArray(data.heatmap_points) && data.heatmap_points.length) {
          radarDidFit = true;
        }
      } catch (e) {}
    } catch (e) {
      console.error("Failed to update radar heatmap:", e);
    }
  }

  function toggleRadar() {
    /**Toggle the availability radar on/off*/
    console.log("toggleRadar called, current state:", radarEnabled);
    const btn = document.getElementById("radar-toggle-btn");
    radarEnabled = !radarEnabled;
    console.log("New radar state:", radarEnabled);

    if (radarEnabled) {
      radarDidFit = false;
        // Expand radius and window for clearer demo coverage
        currentRadiusKm = 8;
        const radiusLbl = document.getElementById("radius-label");
        if (radiusLbl) radiusLbl.textContent = `${currentRadiusKm} km`;
      console.log("Turning radar ON");

      // Use map center as fallback if geolocation not available
      const rawPos = userPosition || map.getCenter();
      console.log("Radar raw position:", rawPos);

      if (!rawPos) {
        console.error("Cannot activate radar - no position available");
        radarEnabled = false;
        return;
      }
      // Normalize to plain {lat, lng}
      const normLat = typeof rawPos.lat === "function" ? rawPos.lat() : rawPos.lat;
      const normLng = typeof rawPos.lng === "function" ? rawPos.lng() : rawPos.lng;
      const radarPosition = { lat: normLat, lng: normLng };

      btn.classList.add("ring-2", "ring-purple-300", "scale-105");
      btn.innerHTML = `
        <svg class="w-4 h-4 animate-pulse" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
        </svg>
        Radar: ON
      `;

      // Update immediately and then every 3 seconds
      console.log("Starting radar updates from position:", radarPosition);
      console.log("Position details - lat:", radarPosition.lat, "lng:", radarPosition.lng);

      updateRadarHeatmapWithPosition(radarPosition);
      recordActivityPingWithPosition(radarPosition);
      radarRefreshInterval = setInterval(() => {
        console.log("Refreshing radar...");
        const raw = userPosition || map.getCenter();
        const cLat = typeof raw.lat === "function" ? raw.lat() : raw.lat;
        const cLng = typeof raw.lng === "function" ? raw.lng() : raw.lng;
        const currentPos = { lat: cLat, lng: cLng };
        updateRadarHeatmapWithPosition(currentPos);
        recordActivityPingWithPosition(currentPos);
      }, 3000);
    } else {
        // Restore default radius
        currentRadiusKm = 3;
        const radiusLbl = document.getElementById("radius-label");
        if (radiusLbl) radiusLbl.textContent = `${currentRadiusKm} km`;
      console.log("Turning radar OFF");
      btn.classList.remove("ring-2", "ring-purple-300", "scale-105");
      btn.innerHTML = `
        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
        </svg>
        Availability Radar
      `;

      if (radarRefreshInterval) {
        clearInterval(radarRefreshInterval);
        radarRefreshInterval = null;
      }
      clearRadarHeatmap();
      clearRadarMarkers();
      clearRadarCircles();

      const statusEl = document.getElementById("map-status");
      if (statusEl) statusEl.innerText = "Radar off. Click to activate.";
    }
  }

  function initMap() {
    const defaultCenter = { lat: 23.75, lng: 90.38 }; // Dhaka-ish

    map = new google.maps.Map(document.getElementById("map"), {
      center: defaultCenter,
      zoom: 13,
      mapTypeControl: false,
      streetViewControl: false,
      fullscreenControl: false,
      styles: [
        { elementType: "geometry", stylers: [{ color: "#020617" }] },
        { elementType: "labels.text.fill", stylers: [{ color: "#e5e7eb" }] },
        { elementType: "labels.text.stroke", stylers: [{ color: "#020617" }] },
        { featureType: "poi", stylers: [{ visibility: "off" }] },
        { featureType: "road", stylers: [{ color: "#0f172a" }] },
        { featureType: "water", stylers: [{ color: "#020617" }] },
      ],
    });

    // Track user interaction so we don't keep auto-zooming
    map.addListener("dragstart", () => {
      userInteractedWithMap = true;
    });
    map.addListener("click", () => {
      userInteractedWithMap = true;
    });
    map.addListener("zoom_changed", () => {
      if (!programmaticZoom) userInteractedWithMap = true;
    });

    const statusEl = document.getElementById("map-status");

    // Recenter button
    document.getElementById("recenter-btn").addEventListener("click", () => {
      if (userPosition) {
        map.setCenter(userPosition);
        map.setZoom(14);
      }
    });

    // Radar toggle button
    document.getElementById("radar-toggle-btn").addEventListener("click", toggleRadar);

    // Filter buttons
    document.querySelectorAll(".filter-btn").forEach((btn) => {
      btn.addEventListener("click", () => {
        activeFilter = btn.getAttribute("data-filter");
        document.querySelectorAll(".filter-btn").forEach((b) => {
          b.classList.remove(
            "border-emerald-400/60",
            "bg-emerald-500/10",
            "text-emerald-200",
            "font-semibold"
          );
          b.classList.add("border-slate-700", "text-slate-300");
        });
        btn.classList.remove("border-slate-700", "text-slate-300");
        btn.classList.add(
          "border-emerald-400/60",
          "bg-emerald-500/10",
          "text-emerald-200",
          "font-semibold"
        );

        const allBtn = document.querySelector('.filter-btn[data-filter="all"]');
        if (allBtn && activeFilter !== "all") {
          allBtn.classList.remove(
            "border-emerald-400/60",
            "bg-emerald-500/10",
            "text-emerald-200",
            "font-semibold"
          );
          allBtn.classList.add("border-slate-700", "text-slate-300");
        }

        renderRequests();
      });
    });

    // Geolocation
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          userPosition = {
            lat: pos.coords.latitude,
            lng: pos.coords.longitude,
          };
          statusEl.innerText = "Location detected. Loading nearby helpâ€¦";

          // Save last-known location for distance-based SOS broadcasts
          fetch("/api/user/location", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              lat: userPosition.lat,
              lng: userPosition.lng,
            }),
          }).catch(() => {});

          map.setCenter(userPosition);

          userMarker = new google.maps.Marker({
            position: userPosition,
            map: map,
            title: "Your location",
            icon: {
              path: google.maps.SymbolPath.CIRCLE,
              scale: 6,
              fillColor: "#22c55e",
              fillOpacity: 1,
              strokeColor: "#bbf7d0",
              strokeWeight: 2,
            },
          });

          fetchAndRenderRequests();
          setInterval(fetchAndRenderRequests, 10000); // auto refresh
        },
        (err) => {
          console.error(err);
          statusEl.innerText =
            "Could not access your location. Showing area around Dhaka.";
          fetchAndRenderRequests();
        }
      );
    } else {
      statusEl.innerText =
        "Geolocation not supported. Showing area around Dhaka.";
      fetchAndRenderRequests();
    }
  }

  function clearRequestMarkers() {
    for (const item of requestMarkers) {
      item.marker.setMap(null);
    }
    requestMarkers = [];

    for (const c of helperCircles) {
      c.setMap(null);
    }
    helperCircles = [];
  }

  async function fetchAndRenderRequests() {
    const statusEl = document.getElementById("map-status");
    const radiusLabel = document.getElementById("radius-label");
    radiusLabel.textContent = `${currentRadiusKm} km`;
    statusEl.innerText = "Loading nearby helpâ€¦";

    try {
      const lat = userPosition ? userPosition.lat : 23.75;
      const lng = userPosition ? userPosition.lng : 90.38;

      const resp = await fetch(
        `/api/requests/nearby?lat=${lat}&lng=${lng}&radius_km=${currentRadiusKm}`
      );
      const data = await resp.json();

      clearRequestMarkers();
      lastRequests = data.requests || [];

      if (!lastRequests.length) {
        statusEl.innerText =
          "No nearby help requests or offers in the last hour.";
        renderRequests();
        return;
      }

      const bounds = new google.maps.LatLngBounds();

      for (const r of lastRequests) {
        const pos = { lat: r.lat, lng: r.lng };

        const isSos = (r.category || "").toLowerCase() === "sos";

        const urgencyRaw = (r.urgency || "normal").toLowerCase();
        const urgency = ["low", "normal", "high", "emergency"].includes(
          urgencyRaw
        )
          ? urgencyRaw
          : "normal";

        const isOffer = !!r.is_offer;
        const roleKey = isOffer ? "offer" : "need";

        let iconUrl =
          (ICON_URLS[roleKey] && ICON_URLS[roleKey][urgency]) ||
          (ICON_URLS[roleKey] && ICON_URLS[roleKey].normal) ||
          ICON_URLS.need.normal;

        const marker = new google.maps.Marker({
          position: pos,
          map: map,
          title: r.title,
          icon: iconUrl,
        });

        const infoWindow = new google.maps.InfoWindow({
          content: "",
        });

        marker.addListener("click", () => {
          try {
            infoWindow.setContent(buildRequestInfoHtml(r));
          } catch (e) {}
          infoWindow.open(map, marker);
        });

        requestMarkers.push({ marker, infoWindow, data: r });
        bounds.extend(pos);

        // Draw helper radius if this is an offer and radius_pref is set
        if (isOffer && r.radius_pref) {
          const radiusKm = parseFloat(r.radius_pref);
          if (!isNaN(radiusKm) && radiusKm > 0) {
            const circle = new google.maps.Circle({
              map: map,
              center: pos,
              radius: radiusKm * 1000,
              strokeColor: "#38bdf8",
              strokeOpacity: 0.4,
              strokeWeight: 1,
              fillColor: "#38bdf8",
              fillOpacity: 0.05,
            });
            helperCircles.push(circle);
          }
        }
      }

      if (userPosition) bounds.extend(userPosition);
      // Avoid periodic auto-zooming: only fit once, and never when focusing a request.
      if (!INITIAL_FOCUS_ID && !userInteractedWithMap && !mapDidInitialFit) {
        mapDidInitialFit = true;
        map.fitBounds(bounds, 80);
      }

      statusEl.innerText = `Showing ${lastRequests.length} nearby request(s) and offer(s) within ${currentRadiusKm} km.`;

      // SOS pulse overlays (hex signal)
      syncSosPulsesFromRequests(lastRequests);

      renderRequests();

      // Auto-focus on SOS (or any request) when redirected here
      if (!autoFocusDone) {
        const focusId = getQueryParamInt("focus_request_id");
        if (focusId) {
          autoFocusDone = true;
          focusOnRequest(focusId);
          startSosResponderTracking(focusId);
          if (getQueryParamBool("sos_caller")) {
            startSosCallerFallbackTimer(focusId);
          }
        }
      }
    } catch (e) {
      console.error(e);
      statusEl.innerText = "Failed to load nearby requests.";
    }
  }

  function renderRequests() {
    const listEl = document.getElementById("requests-list");
    const summaryEl = document.getElementById("requests-summary");

    listEl.innerHTML = "";

    let filtered = lastRequests;
    if (activeFilter !== "all") {
      filtered = lastRequests.filter((r) => r.type === activeFilter);
    }

    if (!filtered.length) {
      summaryEl.innerText = "No requests match the current filter.";
      return;
    }

    summaryEl.innerText = `${filtered.length} request(s) nearby. Click a card to focus on the map.`;

    for (const r of filtered) {
      const isOffer = !!r.is_offer;
      const isSos = (r.category || "").toLowerCase() === "sos";
      const viewerResponded = !!r.viewer_sos_responded;

      let tagLabel = "Help needed";
      let tagColor = "text-emerald-300 bg-emerald-500/10 border-emerald-400/40";

      if (isSos) {
        tagLabel = "SOS Signal";
        tagColor = "text-rose-300 bg-rose-500/10 border-rose-400/40";
      }

      if (!isSos && isOffer) {
        tagLabel = "Helper (general)";
        tagColor = "text-sky-300 bg-sky-500/10 border-sky-400/40";
      } else if (!isSos && r.type === "medicine") {
        tagLabel = "Medicine run";
        tagColor = "text-sky-300 bg-sky-500/10 border-sky-400/40";
      } else if (!isSos && r.type === "ride") {
        tagLabel = "Ride offer";
        tagColor = "text-amber-300 bg-amber-500/10 border-amber-400/40";
      }

      const urgencyText = r.urgency ? r.urgency : null;

      const card = document.createElement("button");
      card.type = "button";
      card.className = isSos
        ? "btn-sheen card-hover stagger-item w-full text-left rounded-2xl border border-rose-500/30 bg-slate-900/90 px-3 py-2.5 hover:border-rose-400 hover:bg-slate-900 transition flex flex-col gap-1"
        : "btn-sheen card-hover stagger-item w-full text-left rounded-2xl border border-slate-800 bg-slate-900/90 px-3 py-2.5 hover:border-emerald-400 hover:bg-slate-900 transition flex flex-col gap-1";
      card.dataset.requestId = r.id;

      card.innerHTML = `
        <div class="flex items-center justify-between gap-2">
          <p class="font-semibold text-slate-100 text-[13px] line-clamp-1">${
            r.title
          }</p>
          <span class="text-[10px] px-2 py-1 rounded-full border ${tagColor}">
            ${tagLabel}
          </span>
        </div>
        <p class="text-[11px] text-slate-400 line-clamp-2">
          ${r.description || ""}
        </p>
        <p class="text-[11px] text-emerald-300 mt-1">
          ~ ${r.distance_km} km away
          ${r.is_offer && r.radius_pref ? ` â€¢ radius ${r.radius_pref} km` : ""}
        </p>
        ${
          urgencyText
            ? `<p class="text-[10px] ${
                isSos ? "text-rose-300" : "text-orange-300"
              } mt-0.5 capitalize">Urgency: ${urgencyText}</p>`
            : ""
        }
        ${
          isSos && IS_TRUSTED_HELPER && viewerResponded
            ? `<p class="text-[10px] text-emerald-400 font-semibold mt-0.5">âœ“ You responded</p>`
            : ""
        }
      `;

      card.addEventListener("click", () => {
        const mode = r.is_offer ? "offer" : "need";
        window.location.href = `/requests?mode=${mode}&open=${r.id}`;
      });

      listEl.appendChild(card);
    }

    // Ensure newly inserted cards animate (stagger observer runs at page load only)
    try {
      if (typeof window.lifelineObserveStaggerItems === "function") {
        window.lifelineObserveStaggerItems(listEl);
      }
    } catch (e) {}
  }

  function focusOnRequest(requestId) {
    const item = requestMarkers.find((m) => m.data.id === requestId);
    if (!item) return;
    map.panTo({ lat: item.data.lat, lng: item.data.lng });
    programmaticZoom = true;
    map.setZoom(15);
    setTimeout(() => {
      programmaticZoom = false;
    }, 0);
    try {
      item.infoWindow.setContent(buildRequestInfoHtml(item.data));
    } catch (e) {}
    item.infoWindow.open(map, item.marker);
  }
</script>

<script
  async
  defer
  src="https://maps.googleapis.com/maps/api/js?key={{ google_maps_key }}&libraries=visualization&callback=initMap"
></script>

{% endblock %}
